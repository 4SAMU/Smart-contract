# Subcurrency Example

The above contract implements the simplest form of a cryptocurrency.
The contract allows only its creator to create new coins. Anyone can send coins to each other without a need for registering with a username and a password, all you need is an Ethereum keypair.

# Key concepts

`address public minter;` declares a state variable of type address.
`address` type is a 160-bit value that does not allow any arithmetic operations. it is suitable for storing address of contracts, or a hash of the public half of a keypair belonging to [external accounts].
The keyword `public` automatically generates a function that allows you to access the current value of the state variable from outside of the contract. Without this keyword, other contracts have no way to access the variable.
The code of the function generated by the compiler is equivalent to the following

```bash
function minter() external view returns (address) { return minter; }
```

`mapping (address => uint) public balances;` also creates a public state variable, but it is a more complex datatype.
The mapping type maps addresses to unsigned integers.
Mapping can be seen as hash tables which are virtually initialised such that every possible key exists from the start and is mapped to a value whose byte-representaion is all zeros.

The line `event Sent(address from, address to, uint amount);` declares an [“event”], which is emitted in the last line of the `function send`.
As soon as it is emitted, the listener receives the arguments `from`, `to` and `amount`, which makes it possible to track transactions.

# you can listen to this event through a javascript code as below

```bash
Coin.Sent().watch({}, '', function(error, result) {
    if (!error) {
        console.log("Coin transfer: " + result.args.amount +
            " coins were sent from " + result.args.from +
            " to " + result.args.to + ".");
        console.log("Balances now:\n" +
            "Sender: " + Coin.balances.call(result.args.from) +
            "Receiver: " + Coin.balances.call(result.args.to));
    }
})
```
